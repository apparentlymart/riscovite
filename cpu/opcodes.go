package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strings"
)

const OpcodeOp = "0110011"
const OpcodeOpImm = "0010011"
const Func7Add = "0000000"
const Func7Sub = "0100000"
const Func7Mul = "0000001"

type Instr struct {
	Mnemonic string
	Pattern  string
}

func main() {
	f, err := os.Open("opcodes.txt")
	if err != nil {
		log.Fatal(err)
	}

	var instrs []Instr
	var maxLen int

	sc := bufio.NewScanner(f)
	for sc.Scan() {
		line := sc.Text()
		space := strings.Index(line, " ")
		if space < 0 {
			log.Fatalf("line %q has no spaces", line)
		}
		mnem := strings.TrimSpace(line[:space])
		pattern := strings.TrimSpace(line[space:])
		if len(pattern) != 32 {
			log.Fatalf("%s has %d bits; want 32", mnem, len(pattern))
		}

		instrs = append(instrs, Instr{
			Mnemonic: mnem,
			Pattern:  pattern,
		})

		if len(mnem) > maxLen {
			maxLen = len(mnem)
		}
	}

	of, err := os.Create("opcodes.v")
	if err != nil {
		log.Fatal(err)
	}

	fmt.Fprint(of, "// Generated by opcodes.go from opcodes.txt; do not edit directly\n\n")

	fmt.Fprintln(of, "// Full instruction patterns")
	for _, instr := range instrs {
		fmt.Fprintf(of, "`define INSTR_%-*s 32'b%s\n", maxLen, instr.Mnemonic, instr.Pattern)
	}

	fmt.Fprintln(of, "\n// ALU Functions")
	for _, instr := range instrs {
		opcode := instr.Pattern[32-7:]
		funct3 := instr.Pattern[32-15 : 32-12]
		funct7 := instr.Pattern[0:7]
		funct7_5 := funct7[1:2]
		if opcode != OpcodeOp || (funct7 != Func7Add && funct7 != Func7Sub) {
			continue
		}
		fmt.Fprintf(of, "`define ALU_%-4s 4'b%s%s\n", instr.Mnemonic, funct7_5, funct3)
	}

	fmt.Fprintln(of, "\n// Multiplier Unit Functions")
	for _, instr := range instrs {
		opcode := instr.Pattern[32-7:]
		funct3 := instr.Pattern[32-15 : 32-12]
		funct7 := instr.Pattern[0:7]
		if opcode != OpcodeOp || funct7 != Func7Mul {
			continue
		}
		fmt.Fprintf(of, "`define MULU_%-6s 3'b%s\n", instr.Mnemonic, funct3)
	}
}
